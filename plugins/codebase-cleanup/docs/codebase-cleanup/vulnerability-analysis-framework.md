# Vulnerability Analysis Framework

**Version**: 1.0.3
**Category**: codebase-cleanup
**Purpose**: Systematic vulnerability assessment, prioritization, and remediation planning

## Vulnerability Classification

### Severity Levels

**Critical (CVSS 9.0-10.0)**:
- Remote code execution (RCE)
- Authentication bypass
- SQL injection in core functionality
- Arbitrary file write/upload
- Privilege escalation to admin

**High (CVSS 7.0-8.9)**:
- Cross-site scripting (XSS) with data exfiltration
- Server-side request forgery (SSRF)
- Path traversal
- Insecure deserialization
- Weak cryptography in authentication

**Moderate (CVSS 4.0-6.9)**:
- Information disclosure (non-sensitive)
- Denial of Service (DoS)
- CSRF without significant impact
- Missing security headers
- Weak session management

**Low (CVSS 0.1-3.9)**:
- Self-XSS
- Clickjacking on non-sensitive pages
- Information leakage (version numbers)
- Missing best practices

## Risk Scoring Algorithm

```python
from dataclasses import dataclass
from typing import List, Optional
from enum import Enum

class ExploitMaturity(Enum):
    PROOF_OF_CONCEPT = 1.2
    FUNCTIONAL = 1.5
    HIGH = 2.0
    NOT_DEFINED = 1.0

class AttackVector(Enum):
    NETWORK = 1.5
    ADJACENT = 1.2
    LOCAL = 1.0
    PHYSICAL = 0.8

@dataclass
class VulnerabilityRiskScore:
    cvss_base: float
    is_direct_dependency: bool
    exploit_available: bool
    exploit_maturity: ExploitMaturity
    attack_vector: AttackVector
    publicly_disclosed: bool
    patch_available: bool
    affected_users_count: Optional[int] = None

    def calculate_risk_score(self) -> float:
        """
        Calculate comprehensive risk score

        Formula:
        Risk = CVSS × DirectMult × ExploitMult × VectorMult × DisclosureMult × PatchMult
        """
        score = self.cvss_base

        # Direct dependencies are higher risk (in our control to update)
        if self.is_direct_dependency:
            score *= 1.5

        # Exploit availability significantly increases risk
        if self.exploit_available:
            score *= self.exploit_maturity.value

        # Attack vector affects likelihood
        score *= self.attack_vector.value

        # Public disclosure increases urgency
        if self.publicly_disclosed:
            score *= 1.3

        # No patch available increases risk
        if not self.patch_available:
            score *= 1.4

        # High user impact
        if self.affected_users_count and self.affected_users_count > 1000:
            score *= 1.2

        return min(score, 10.0)  # Cap at 10.0

    def get_remediation_urgency(self) -> str:
        """Determine remediation timeline based on risk score"""
        score = self.calculate_risk_score()

        if score >= 9.0:
            return "immediate"  # < 24 hours
        elif score >= 7.0:
            return "urgent"  # < 1 week
        elif score >= 4.0:
            return "scheduled"  # < 1 month
        else:
            return "backlog"  # Next release
```

## Remediation Strategy Framework

### Decision Tree

```
Is patch available?
├─ YES → Is it breaking change?
│   ├─ YES → Schedule migration sprint
│   └─ NO → Apply patch immediately
└─ NO → Is workaround available?
    ├─ YES → Implement workaround, monitor for patch
    └─ NO → Assess alternatives
        ├─ Alternative package exists? → Migrate
        └─ No alternative? → Custom mitigation + isolate
```

### Remediation Action Templates

```python
class RemediationAction:
    """Define remediation actions for vulnerabilities"""

    @staticmethod
    def patch_update(package: str, current: str, target: str, breaking: bool) -> Dict:
        """Standard patch update action"""
        return {
            'type': 'patch_update',
            'package': package,
            'current_version': current,
            'target_version': target,
            'breaking_change': breaking,
            'estimated_effort': '2-4 hours' if breaking else '30 minutes',
            'steps': [
                f'Update {package} from {current} to {target}',
                'Run full test suite',
                'Verify no regressions' if breaking else 'Smoke test',
                'Deploy to staging',
                'Monitor for 24 hours' if breaking else 'Deploy to production'
            ]
        }

    @staticmethod
    def workaround(vulnerability_id: str, description: str, steps: List[str]) -> Dict:
        """Temporary workaround action"""
        return {
            'type': 'workaround',
            'vulnerability_id': vulnerability_id,
            'description': description,
            'steps': steps,
            'monitoring': 'Check weekly for patch availability',
            'expiration': 'Remove when patch available'
        }

    @staticmethod
    def package_replacement(old_package: str, new_package: str, reason: str) -> Dict:
        """Replace vulnerable package with alternative"""
        return {
            'type': 'package_replacement',
            'old_package': old_package,
            'new_package': new_package,
            'reason': reason,
            'estimated_effort': '1-2 days',
            'steps': [
                f'Install {new_package}',
                f'Refactor code from {old_package} API to {new_package} API',
                'Update tests',
                'Remove {old_package}',
                'Full regression testing'
            ]
        }

    @staticmethod
    def custom_mitigation(vulnerability_type: str, mitigations: List[str]) -> Dict:
        """Custom mitigation when no patch available"""
        return {
            'type': 'custom_mitigation',
            'vulnerability_type': vulnerability_type,
            'mitigations': mitigations,
            'verification': 'Penetration testing required',
            'monitoring': 'Continuous monitoring with alerts'
        }
```

## Vulnerability Report Template

```markdown
# Security Vulnerability Report

**Report ID**: VULN-2024-{id}
**Date**: {date}
**Severity**: {severity}
**Status**: {status}

## Executive Summary
{1-2 sentence description of vulnerability and impact}

## Vulnerability Details

### Affected Components
- **Package**: {package_name}
- **Version**: {affected_versions}
- **Dependency Type**: {direct|transitive}
- **CVE ID**: {cve_id}
- **CWE ID**: {cwe_id}

### Technical Description
{detailed technical explanation}

### Attack Scenario
```
1. Attacker performs {action}
2. System responds with {response}
3. Attacker exploits {weakness}
4. Result: {impact}
```

### CVSS Metrics
- **Base Score**: {score} ({severity})
- **Attack Vector**: {vector}
- **Attack Complexity**: {complexity}
- **Privileges Required**: {privileges}
- **User Interaction**: {interaction}
- **Scope**: {scope}
- **Impact**: Confidentiality: {C} | Integrity: {I} | Availability: {A}

## Impact Assessment

### Business Impact
- **Affected Users**: {count} ({percentage}%)
- **Data at Risk**: {description}
- **Financial Impact**: {estimate}
- **Regulatory Implications**: {compliance_issues}

### Technical Impact
- **Systems Affected**: {list}
- **Attack Surface**: {description}
- **Exploit Difficulty**: {easy|moderate|hard}

## Remediation Plan

### Recommended Action
**Type**: {patch|workaround|replacement|custom}
**Timeline**: {immediate|urgent|scheduled|backlog}
**Estimated Effort**: {hours}

### Implementation Steps
1. {step_1}
2. {step_2}
3. {step_3}

### Verification
- [ ] Vulnerability scan confirms fix
- [ ] Penetration test passes
- [ ] No new issues introduced
- [ ] Documentation updated

### Rollback Plan
{describe how to revert if issues occur}

## References
- CVE: https://cve.mitre.org/cgi-bin/cvename.cgi?name={cve_id}
- Advisory: {url}
- Patch Notes: {url}

## Approval
- **Security Team**: ☐ Approved ☐ Rejected
- **Engineering**: ☐ Reviewed ☐ Implemented
- **QA**: ☐ Verified ☐ Issues Found
```

## Continuous Monitoring

### Automated Scanning Schedule

```yaml
vulnerability_scanning:
  realtime:
    - trigger: dependency_file_change
    - action: run_security_audit
    - notify: slack_security_channel

  daily:
    - time: "02:00 UTC"
    - scan: all_dependencies
    - check: new_advisories
    - report: critical_high_only

  weekly:
    - day: monday
    - scan: full_dependency_tree
    - check: license_compliance
    - check: supply_chain_risks
    - report: comprehensive

  monthly:
    - scan: penetration_testing
    - review: all_moderate_low
    - audit: remediation_backlog
    - report: executive_summary
```

### Alert Thresholds

```python
ALERT_THRESHOLDS = {
    'critical_vulnerability': {
        'immediate_notification': ['security-team', 'cto', 'on-call'],
        'create_incident': True,
        'auto_pr': False,  # Too risky to auto-patch critical
        'max_resolution_time_hours': 24
    },
    'high_vulnerability': {
        'immediate_notification': ['security-team', 'team-lead'],
        'create_incident': True,
        'auto_pr': True,  # Can auto-create PR for review
        'max_resolution_time_hours': 168  # 1 week
    },
    'moderate_vulnerability': {
        'immediate_notification': [],
        'create_incident': False,
        'auto_pr': True,
        'max_resolution_time_hours': 720  # 30 days
    },
    'low_vulnerability': {
        'immediate_notification': [],
        'create_incident': False,
        'auto_pr': True,
        'max_resolution_time_hours': None  # Next release
    }
}
```

## Metrics and KPIs

### Security Posture Dashboard

```python
class SecurityMetrics:
    """Track security vulnerability metrics"""

    def calculate_mean_time_to_remediate(self, vulnerabilities: List[Dict]) -> Dict:
        """Calculate MTTR by severity"""
        mttr_by_severity = {
            'critical': [],
            'high': [],
            'moderate': [],
            'low': []
        }

        for vuln in vulnerabilities:
            if vuln['status'] == 'resolved':
                time_to_fix = (vuln['resolved_date'] - vuln['discovered_date']).total_seconds() / 3600
                mttr_by_severity[vuln['severity']].append(time_to_fix)

        return {
            severity: sum(times) / len(times) if times else 0
            for severity, times in mttr_by_severity.items()
        }

    def calculate_vulnerability_density(self, total_dependencies: int, vulnerabilities: int) -> float:
        """Calculate vulnerabilities per 100 dependencies"""
        return (vulnerabilities / total_dependencies) * 100 if total_dependencies > 0 else 0

    def calculate_exposure_window(self, vulnerabilities: List[Dict]) -> Dict:
        """Average time systems were exposed to vulnerabilities"""
        exposure_times = []

        for vuln in vulnerabilities:
            if vuln['status'] == 'resolved':
                # Time from public disclosure to fix deployment
                exposure = (vuln['deployed_fix_date'] - vuln['public_disclosure_date']).total_seconds() / 3600
                exposure_times.append(exposure)

        return {
            'mean_exposure_hours': sum(exposure_times) / len(exposure_times) if exposure_times else 0,
            'max_exposure_hours': max(exposure_times) if exposure_times else 0
        }
```

### Target SLAs

| Severity | Detection | Remediation | Deployment |
|----------|-----------|-------------|------------|
| Critical | < 1 hour | < 24 hours | < 48 hours |
| High | < 24 hours | < 7 days | < 14 days |
| Moderate | < 1 week | < 30 days | < 60 days |
| Low | < 1 month | Next release | Next release |
