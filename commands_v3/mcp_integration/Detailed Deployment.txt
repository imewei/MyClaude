  Option A does NOT install anything - it just tells Python where to find the code.

  1. Setup (One-Time)

  # Add to your shell profile (~/.bashrc, ~/.zshrc, etc.)
  echo 'export PYTHONPATH=/Users/b80985/.claude/commands:$PYTHONPATH' >> ~/.zshrc

  # Or set it temporarily for current session
  export PYTHONPATH=/Users/b80985/.claude/commands:$PYTHONPATH

  # Verify it's set
  echo $PYTHONPATH
  # Should output: /Users/b80985/.claude/commands:...

  What this does:
  - ✅ Tells Python to look in /Users/b80985/.claude/commands for modules
  - ✅ No installation, no copying files
  - ✅ Works in any Python environment (system, venv, doesn't matter)
  - ✅ Changes to code are immediately available (like editable install)

  2. How to Import and Use

  # From anywhere in your Python code, you can now do:
  from mcp_integration import KnowledgeHierarchy, LibraryCache
  from mcp_integration.learning_system import LearningSystem

  # Python will find the module at:
  # /Users/b80985/.claude/commands/mcp_integration/

  3. How the MCP Integration System Starts

  Method 1: Manual Initialization in Each Command (Simple)

  Each command that needs MCP integration imports and initializes it:

  # In your /fix command file
  import sys
  import asyncio
  from pathlib import Path

  # Ensure PYTHONPATH is set (redundant if you set it in shell, but safe)
  sys.path.insert(0, '/Users/b80985/.claude/commands')

  from mcp_integration import (
      KnowledgeHierarchy,
      LibraryCache,
      create_mcp_adapters,
  )
  from mcp_integration.learning_system import LearningSystem
  from mcp_integration.monitoring import Monitor

  async def execute_fix_command(error_context, mcp_servers):
      """
      Fix command with MCP integration.

      Args:
          error_context: Error information
          mcp_servers: Dict of MCP server instances
              {
                  'memory_bank': memory_bank_mcp,
                  'serena': serena_mcp,
                  'context7': context7_mcp
              }
      """
      # Create adapters
      adapters = await create_mcp_adapters(
          memory_bank_mcp=mcp_servers.get('memory_bank'),
          serena_mcp=mcp_servers.get('serena'),
          context7_mcp=mcp_servers.get('context7'),
      )

      # Initialize hierarchy
      hierarchy = await KnowledgeHierarchy.create(
          memory_bank=adapters.get('memory-bank'),
          serena=adapters.get('serena'),
          context7=adapters.get('context7'),
      )

      # Initialize library cache
      config_dir = Path.home() / ".claude" / "commands"
      lib_cache = await LibraryCache.create(
          str(config_dir / "library-cache.yaml")
      )

      # Use them
      result = await hierarchy.fetch(
          query=f"error:{error_context['type']}",
          context_type="error"
      )

      return result


  # How Claude Code would call this:
  # result = await execute_fix_command(
  #     error_context={'type': 'TypeError', 'file': 'main.py'},
  #     mcp_servers={'memory_bank': memory_bank, 'serena': serena, ...}
  # )

  Pros:
  - ✅ Simple, explicit
  - ✅ No global state
  - ✅ Each command is self-contained

  Cons:
  - ❌ Repeated initialization overhead
  - ❌ No shared learning across commands
  - ❌ No persistent monitoring

  Method 2: Shared Runtime with Lazy Initialization (Recommended)

  Create a shared runtime that initializes once on first use:

  # Create: /Users/b80985/.claude/commands/mcp_shared_runtime.py

  """
  Shared MCP runtime for Option A deployment.
  Uses lazy initialization - starts on first use.
  """

  import asyncio
  from pathlib import Path
  from typing import Optional, Dict, Any

  from mcp_integration import (
      KnowledgeHierarchy,
      LibraryCache,
      MCPProfileManager,
      SmartTrigger,
      create_mcp_adapters,
  )
  from mcp_integration.learning_system import LearningSystem
  from mcp_integration.predictive_preloader import PredictivePreloader
  from mcp_integration.monitoring import Monitor


  class SharedMCPRuntime:
      """
      Shared MCP runtime with lazy initialization.

      Usage:
          from mcp_shared_runtime import get_mcp_runtime

          runtime = await get_mcp_runtime(mcp_servers)
          result = await runtime.hierarchy.fetch(...)
      """

      _instance: Optional['SharedMCPRuntime'] = None
      _initialized: bool = False

      def __init__(self):
          self.hierarchy = None
          self.lib_cache = None
          self.profile_manager = None
          self.smart_trigger = None
          self.learner = None
          self.preloader = None
          self.monitor = None

      @classmethod
      async def get_instance(cls, mcp_servers: Dict[str, Any]) -> 'SharedMCPRuntime':
          """
          Get or create the shared runtime instance.

          Args:
              mcp_servers: Dictionary of MCP server instances
                  {
                      'memory_bank': memory_bank_mcp,
                      'serena': serena_mcp,
                      'context7': context7_mcp,
                      'github': github_mcp (optional),
                  }

          Returns:
              Initialized SharedMCPRuntime instance
          """
          if cls._instance is None:
              cls._instance = cls()

          if not cls._initialized:
              await cls._instance._initialize(mcp_servers)
              cls._initialized = True

          return cls._instance

      async def _initialize(self, mcp_servers: Dict[str, Any]):
          """Initialize all MCP integration components."""
          print("[MCP Runtime] Initializing (lazy init on first use)...")

          config_dir = Path.home() / ".claude" / "commands"

          # Create adapters
          adapters = await create_mcp_adapters(
              memory_bank_mcp=mcp_servers.get('memory_bank'),
              serena_mcp=mcp_servers.get('serena'),
              context7_mcp=mcp_servers.get('context7'),
              github_mcp=mcp_servers.get('github'),
              playwright_mcp=mcp_servers.get('playwright'),
              sequential_thinking_mcp=mcp_servers.get('sequential_thinking'),
          )

          # Initialize components
          self.hierarchy = await KnowledgeHierarchy.create(
              memory_bank=adapters.get('memory-bank'),
              serena=adapters.get('serena'),
              context7=adapters.get('context7'),
              github=adapters.get('github'),
          )

          self.lib_cache = await LibraryCache.create(
              str(config_dir / "library-cache.yaml"),
              context7_mcp=adapters.get('context7')
          )

          self.profile_manager = await MCPProfileManager.create(
              str(config_dir / "mcp-profiles.yaml")
          )

          self.smart_trigger = await SmartTrigger.create(
              str(config_dir / "mcp-config.yaml")
          )

          self.learner = await LearningSystem.create(
              memory_bank=adapters.get('memory-bank')
          )

          self.preloader = await PredictivePreloader.create(
              profile_manager=self.profile_manager,
              learning_system=self.learner
          )

          self.monitor = await Monitor.create()

          # Start background tasks
          await self.preloader.start_background_preloading()

          print("[MCP Runtime] ✓ Initialized")


  # Convenience function
  async def get_mcp_runtime(mcp_servers: Dict[str, Any]) -> SharedMCPRuntime:
      """
      Get the shared MCP runtime (initializes on first call).

      Usage:
          runtime = await get_mcp_runtime({
              'memory_bank': memory_bank_mcp,
              'serena': serena_mcp,
              'context7': context7_mcp,
          })

          result = await runtime.hierarchy.fetch(...)
      """
      return await SharedMCPRuntime.get_instance(mcp_servers)

  Using the Shared Runtime in Commands

  # In your /fix command
  from mcp_shared_runtime import get_mcp_runtime
  from mcp_integration.learning_system import OutcomeType

  async def execute_fix_command(error_context, mcp_servers):
      """
      Fix command using shared MCP runtime.

      Args:
          error_context: Error information
          mcp_servers: Dict of MCP instances
      """
      # Get shared runtime (initializes on first call, reuses thereafter)
      runtime = await get_mcp_runtime(mcp_servers)

      # 1. Activate profile
      await runtime.profile_manager.activate_for_command("fix")

      # 2. Check for cached solution
      async with runtime.monitor.track_mcp_call("memory-bank", "error"):
          solution = await runtime.hierarchy.fetch(
              query=f"error:{error_context['type']}",
              context_type="error"
          )

      if solution.success:
          print(f"Found cached solution from {solution.source.value}")

      # 3. Apply fix (your logic here)
      fix_applied = True  # Your fix logic

      # 4. Track learning
      outcome = OutcomeType.SUCCESS if fix_applied else OutcomeType.FAILURE
      await runtime.learner.track_success(
          query=f"error:{error_context['type']}",
          mcps_used=['memory-bank', 'serena'],
          outcome=outcome,
          latency_ms=solution.latency_ms
      )

      return solution


  # In your /quality command
  async def execute_quality_command(target_path, mcp_servers):
      """Quality command using shared runtime."""
      runtime = await get_mcp_runtime(mcp_servers)

      # Predictive preloading
      await runtime.preloader.preload_for_command(
          "quality",
          context={'path': target_path}
      )

      # Get quality baseline
      baseline = await runtime.hierarchy.fetch(
          "quality_baseline:project",
          context_type="quality_baseline"
      )

      return baseline


  # In your /ultra-think command
  async def execute_ultra_think_command(query, mcp_servers):
      """Ultra-think using shared runtime."""
      runtime = await get_mcp_runtime(mcp_servers)

      # Smart trigger determines which MCPs to use
      trigger_result = runtime.smart_trigger.analyze(query, "ultra-think")
      print(f"Recommended MCPs: {trigger_result.recommended_mcps}")

      # Use hierarchy
      result = await runtime.hierarchy.fetch(query, context_type="general")

      return result

  4. Complete Option A Setup Flow

  # Step 1: Set PYTHONPATH (one-time, add to ~/.zshrc)
  export PYTHONPATH=/Users/b80985/.claude/commands:$PYTHONPATH

  # Step 2: Create shared runtime file
  cat > /Users/b80985/.claude/commands/mcp_shared_runtime.py << 'EOF'
  # ... (paste the SharedMCPRuntime code from above)
  EOF

  # Step 3: Test it works
  python << 'EOF'
  import sys
  sys.path.insert(0, '/Users/b80985/.claude/commands')

  from mcp_integration import KnowledgeHierarchy
  print("✓ Option A working - can import mcp_integration")
  EOF

  # Step 4: Test shared runtime
  python << 'EOF'
  import asyncio
  import sys
  sys.path.insert(0, '/Users/b80985/.claude/commands')

  from mcp_shared_runtime import get_mcp_runtime

  class MockMCP:
      async def fetch(self, *args, **kwargs):
          return None
      async def store(self, *args, **kwargs):
          return True

  async def test():
      runtime = await get_mcp_runtime({
          'memory_bank': MockMCP(),
          'serena': MockMCP(),
          'context7': MockMCP(),
      })
      print(f"✓ Runtime initialized")
      print(f"  - Hierarchy: {runtime.hierarchy is not None}")
      print(f"  - Library Cache: {runtime.lib_cache is not None}")
      print(f"  - Monitor: {runtime.monitor is not None}")

  asyncio.run(test())
  EOF

  5. How Commands Call This

  Here's how Claude Code's command system would integrate:

  # Hypothetical: Claude Code's command dispatcher

  import asyncio
  from pathlib import Path
  import sys

  # Set PYTHONPATH programmatically (if not set in environment)
  sys.path.insert(0, '/Users/b80985/.claude/commands')

  from mcp_shared_runtime import get_mcp_runtime

  class CommandDispatcher:
      def __init__(self, mcp_servers):
          """
          Args:
              mcp_servers: Dict of initialized MCP servers
          """
          self.mcp_servers = mcp_servers

      async def execute_command(self, command_name: str, args: dict):
          """Execute a command with MCP integration."""

          # Get shared runtime (initializes once, reuses thereafter)
          runtime = await get_mcp_runtime(self.mcp_servers)

          # Dispatch to specific command
          if command_name == "fix":
              return await self.execute_fix(args, runtime)
          elif command_name == "quality":
              return await self.execute_quality(args, runtime)
          # ... etc

      async def execute_fix(self, args, runtime):
          """Fix command implementation."""
          await runtime.profile_manager.activate_for_command("fix")

          async with runtime.monitor.track_mcp_call("memory-bank"):
              result = await runtime.hierarchy.fetch(
                  query=args['query'],
                  context_type="error"
              )

          return result


  # Usage:
  async def main():
      # Initialize MCP servers (your existing code)
      mcp_servers = {
          'memory_bank': await init_memory_bank(),
          'serena': await init_serena(),
          'context7': await init_context7(),
      }

      # Create dispatcher
      dispatcher = CommandDispatcher(mcp_servers)

      # Execute commands (MCP integration happens automatically)
      await dispatcher.execute_command("fix", {"query": "TypeError in main.py"})
      await dispatcher.execute_command("quality", {"path": "src/"})

  asyncio.run(main())

  6. Option A vs Option B Comparison

  | Aspect       | Option A (PYTHONPATH)       | Option B (pip install -e)         |
  |--------------|-----------------------------|-----------------------------------|
  | Installation | Set environment variable    | Run pip install -e                |
  | Virtual Env  | No, affects all Python      | Yes, installs to active env       |
  | Portability  | Requires PYTHONPATH set     | Works automatically after install |
  | Ease of Use  | Need to remember to set env | Just import                       |
  | Best For     | Quick testing, development  | Production, team environments     |
  | Cleanup      | Just unset PYTHONPATH       | pip uninstall mcp-integration     |

  7. Recommendation for Option A

  Use Option A if:
  - You're testing/developing
  - You want quick iteration
  - You don't want to install anything
  - You're the only user

  Use the Shared Runtime pattern (Method 2) because:
  - ✅ Initializes once (fast)
  - ✅ Shared learning across commands
  - ✅ Persistent monitoring
  - ✅ Efficient resource usage

  Summary

  Option A Setup:
  1. export PYTHONPATH=/Users/b80985/.claude/commands:$PYTHONPATH
  2. Create mcp_shared_runtime.py (shown above)
  3. Commands call get_mcp_runtime(mcp_servers)
  4. Runtime initializes on first use, reuses thereafter

  No installation needed - just set PYTHONPATH and import!



  Option B: Install as Package (Detailed)

  1. Installation Process

  # Navigate to the directory containing mcp_integration/
  cd /Users/b80985/.claude/commands

  # Install in editable mode to your current Python environment
  pip install -e mcp_integration/

  What happens:
  - ✅ Creates a symlink in your Python environment's site-packages/
  - ✅ The package points to /Users/b80985/.claude/commands/mcp_integration/
  - ✅ Any changes you make are immediately reflected (no reinstall needed)
  - ✅ You can import it from anywhere: from mcp_integration import ...

  To check installation:
  pip list | grep mcp-integration
  # Should show: mcp-integration 1.0.0 /Users/b80985/.claude/commands/mcp_integration

  2. Where It Gets Installed

  If you have a virtual environment active:
  # It installs to your venv
  ~/.virtualenvs/your-env/lib/python3.x/site-packages/mcp-integration.egg-link
  # (This is just a pointer to the actual code)

  If you DON'T have a virtual environment:
  # It installs to your system/user Python
  ~/.local/lib/python3.x/site-packages/mcp-integration.egg-link
  # or
  /usr/local/lib/python3.x/site-packages/mcp-integration.egg-link

  3. How the MCP Integration System Starts

  The system needs to be initialized when Claude Code starts. Here's how:

  Step 1: Create Runtime Initialization File

  # Create the runtime initialization file
  cat > /Users/b80985/.claude/commands/mcp_runtime_init.py << 'EOF'
  """
  MCP Integration Runtime - Auto-initializes when Claude Code starts
  """

  import asyncio
  from pathlib import Path
  from mcp_integration import (
      KnowledgeHierarchy,
      LibraryCache,
      MCPProfileManager,
      SmartTrigger,
      create_mcp_adapters,
  )
  from mcp_integration.learning_system import LearningSystem
  from mcp_integration.predictive_preloader import PredictivePreloader
  from mcp_integration.monitoring import Monitor


  class MCPRuntime:
      """Global MCP integration runtime - singleton pattern."""

      _instance = None

      def __new__(cls):
          if cls._instance is None:
              cls._instance = super().__new__(cls)
              cls._instance._initialized = False
          return cls._instance

      def __init__(self):
          if self._initialized:
              return

          self.hierarchy = None
          self.lib_cache = None
          self.profile_manager = None
          self.smart_trigger = None
          self.learner = None
          self.preloader = None
          self.monitor = None
          self._initialized = False

      async def initialize(
          self,
          memory_bank_mcp,
          serena_mcp,
          context7_mcp,
          github_mcp=None,
          playwright_mcp=None,
          sequential_thinking_mcp=None,
      ):
          """
          Initialize MCP integration system.
          Called once during Claude Code startup.
          """
          if self._initialized:
              print("[MCP Runtime] Already initialized")
              return

          print("[MCP Runtime] Initializing...")

          # Config directory
          config_dir = Path.home() / ".claude" / "commands"

          # Create MCP adapters
          adapters = await create_mcp_adapters(
              memory_bank_mcp=memory_bank_mcp,
              serena_mcp=serena_mcp,
              context7_mcp=context7_mcp,
              github_mcp=github_mcp,
              playwright_mcp=playwright_mcp,
              sequential_thinking_mcp=sequential_thinking_mcp,
          )

          # Initialize knowledge hierarchy
          self.hierarchy = await KnowledgeHierarchy.create(
              memory_bank=adapters.get('memory-bank'),
              serena=adapters.get('serena'),
              context7=adapters.get('context7'),
              github=adapters.get('github'),
          )

          # Initialize library cache
          self.lib_cache = await LibraryCache.create(
              str(config_dir / "library-cache.yaml"),
              context7_mcp=adapters.get('context7')
          )

          # Initialize profile manager
          self.profile_manager = await MCPProfileManager.create(
              str(config_dir / "mcp-profiles.yaml")
          )

          # Initialize smart trigger
          self.smart_trigger = await SmartTrigger.create(
              str(config_dir / "mcp-config.yaml")
          )

          # Initialize learning system
          self.learner = await LearningSystem.create(
              memory_bank=adapters.get('memory-bank')
          )

          # Initialize predictive preloader
          self.preloader = await PredictivePreloader.create(
              profile_manager=self.profile_manager,
              learning_system=self.learner
          )

          # Initialize monitoring
          self.monitor = await Monitor.create()

          # Start background tasks
          await self.preloader.start_background_preloading()

          self._initialized = True
          print("[MCP Runtime] ✓ Initialized successfully")

      async def shutdown(self):
          """Cleanup on shutdown."""
          if not self._initialized:
              return

          print("[MCP Runtime] Shutting down...")

          if self.preloader:
              await self.preloader.stop_background_preloading()

          if self.monitor:
              await self.monitor.stop()

          self._initialized = False
          print("[MCP Runtime] ✓ Shutdown complete")


  # Global singleton instance
  mcp_runtime = MCPRuntime()


  async def init_mcp_integration(
      memory_bank_mcp,
      serena_mcp,
      context7_mcp,
      **kwargs
  ):
      """
      Convenience function to initialize MCP integration.

      Call this from Claude Code's startup routine.

      Example:
          await init_mcp_integration(
              memory_bank_mcp=memory_bank,
              serena_mcp=serena,
              context7_mcp=context7,
              github_mcp=github
          )
      """
      await mcp_runtime.initialize(
          memory_bank_mcp,
          serena_mcp,
          context7_mcp,
          **kwargs
      )


  # Export for easy access
  __all__ = ['mcp_runtime', 'init_mcp_integration']
  EOF

  Step 2: How Claude Code Initializes It

  In Claude Code's main startup file (wherever that is):

  # claude_code_startup.py (or wherever Claude Code initializes)

  import asyncio
  from mcp_runtime_init import init_mcp_integration

  async def startup():
      """Claude Code startup routine."""

      # ... existing initialization ...

      # Initialize MCP servers (your existing code)
      memory_bank = await initialize_memory_bank()
      serena = await initialize_serena()
      context7 = await initialize_context7()
      github = await initialize_github()

      # Initialize MCP integration system
      await init_mcp_integration(
          memory_bank_mcp=memory_bank,
          serena_mcp=serena,
          context7_mcp=context7,
          github_mcp=github
      )

      print("✓ Claude Code ready with MCP integration")

  # Run startup
  asyncio.run(startup())

  Step 3: Using It in Your Commands

  Once initialized, any command can use it:

  # In /fix command
  from mcp_runtime_init import mcp_runtime

  async def execute_fix_command(error_context):
      """Fix command with MCP integration."""

      # 1. Activate profile
      await mcp_runtime.profile_manager.activate_for_command("fix")

      # 2. Check for cached solutions
      result = await mcp_runtime.hierarchy.fetch(
          query=f"error:{error_context['type']}",
          context_type="error"
      )

      # 3. Track monitoring
      async with mcp_runtime.monitor.track_mcp_call("memory-bank"):
          # ... your fix logic ...
          pass

      return result

  4. Complete Installation & Startup Flow

  # 1. Install package (one-time setup)
  cd /Users/b80985/.claude/commands
  pip install -e mcp_integration/

  # 2. Verify installation
  python -c "from mcp_integration import KnowledgeHierarchy; print('✓ Installed')"

  # 3. Create runtime init file (already shown above)
  # File: /Users/b80985/.claude/commands/mcp_runtime_init.py

  # 4. Test initialization
  python << 'EOF'
  import asyncio
  from mcp_runtime_init import init_mcp_integration

  class MockMCP:
      async def fetch(self, *args, **kwargs):
          return None
      async def store(self, *args, **kwargs):
          return True

  async def test():
      await init_mcp_integration(
          memory_bank_mcp=MockMCP(),
          serena_mcp=MockMCP(),
          context7_mcp=MockMCP()
      )
      print("✓ MCP Runtime initialized successfully")

  asyncio.run(test())
  EOF

  5. Alternative: If Claude Code Doesn't Have Central Startup

  If Claude Code doesn't have a central startup file, you can use lazy initialization:

  # mcp_runtime_init.py (modified)

  class MCPRuntime:
      # ... existing code ...

      async def ensure_initialized(self, mcp_servers):
          """Initialize if not already initialized."""
          if not self._initialized:
              await self.initialize(**mcp_servers)

  # In commands, initialize on first use:
  async def execute_command():
      # Auto-initialize on first use
      if not mcp_runtime._initialized:
          await mcp_runtime.initialize(
              memory_bank_mcp=get_memory_bank(),
              serena_mcp=get_serena(),
              context7_mcp=get_context7()
          )

      # Use it
      result = await mcp_runtime.hierarchy.fetch(...)

  6. Summary

  Option B Installation:
  1. ✅ Run: pip install -e mcp_integration/
  2. ✅ Creates symlink in your Python environment
  3. ✅ Editable mode - changes reflect immediately
  4. ✅ Importable from anywhere

  How It Starts:
  1. ✅ Create mcp_runtime_init.py (shown above)
  2. ✅ Call init_mcp_integration() during Claude Code startup
  3. ✅ Use mcp_runtime singleton in all commands
  4. ✅ Automatically handles initialization, cleanup

  Key Advantage:
  - One-time initialization at startup
  - All commands share the same runtime
  - No repeated setup overhead
  - Clean singleton pattern